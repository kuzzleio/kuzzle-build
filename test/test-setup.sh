#!/bin/bash

remove_container() {
    echo "Removing container..."
    docker kill $CONTAINER_NAME > /dev/null
    echo "Done."
}

DIST=$1

if [ "$2" = "--show-debug" ]; then
    OUTPUT=""
    export SETUPSH_SHOW_DEBUG=1
else
    OUTPUT="> /dev/null"
fi

IMAGE_NAME=kuzzleio/setupsh-test-$DIST
CONTAINER_NAME=setupsh-test-$DIST

echo
echo "$(tput bold) Testing Setup.sh on $DIST"
echo " ================================$(tput sgr0)"
echo
echo " Setting up test environment..."

# Build and start docker container
docker run -d -e SETUPSH_SHOW_DEBUG -e COMPOSE_HTTP_TIMEOUT -e DOCKER_CLIENT_TIMEOUT -e CONNECT_TO_KUZZLE_MAX_RETRY --privileged --rm --name $CONTAINER_NAME -v $PWD:/opt $IMAGE_NAME $OUTPUT
EXIT_VALUE=$?
if [ $EXIT_VALUE -ne 0 ]; then
    exit $EXIT_VALUE
fi

trap remove_container INT
trap remove_container EXIT

echo

### Notice about the exit code of each test ###
###############################################
#
# Dear developer that comes after me (or dear myself in 6 months),
# as you examine this code, you'll probably notice the weird
#
#    && exit 0
#
# after each call to the test script setupsh.should.
# Yes, this is weird but, as you may guess, it's not troll-code.
# The problem addressed here is that, on some distributions
# (e.g. Fedora), the exit code generated by the test script is
# not propagated outside the container once the docker exec
# is done with the command (refer to
# https://docs.docker.com/engine/reference/run/#exit-status).
# The common case is to get 129 no matter if the test
# failed or succeeded.
# We don't really understand what 129 exactly means (refer to
# http://tldp.org/LDP/abs/html/exitcodes.html), so we tried many
# hacks, like
#
#    ; exit $?
#    ; echo $?
#
# but none worked (both return 0 in any case).
# By total chance, we simply noticed that with this && hack, if
# the test fails (i.e. exit code is greater than 0), the shell
# interrupts the command chain and exits with the right code.
# Instead, if the test succeeds, the command chain is followed
# and exited with 0.
#
# Notice that this only happens on some distributions. On Debian,
# for example, we have no problem and things were perfect without
# the hack. If you have any clue to make this less hacky and painful,
# please, spread the love.
#


# Test - Check cUrl
#########################################

# We only test cUrl if the tested distribution comes
# without it (like, Fedora comes with cUrl)
if [ -z $(docker exec -t $CONTAINER_NAME sh -c "command -v curl") ]; then
    docker exec -t $CONTAINER_NAME sh -ec "./setupsh.should \"fail if curl is not installed\" \"This script needs curl\" 43 && exit 0"
    EXIT_VALUE=$?
    if [ $EXIT_VALUE -ne 0 ]; then
        exit $EXIT_VALUE
    fi
fi


# Test - Check internet connection
#########################################

# Setup (install curl and shut eth0 down)
echo " Installing curl..."
sh -c "docker exec -t $CONTAINER_NAME /opt/test/fixtures-setupsh/install-curl.sh $OUTPUT" 
echo " Shutting down eth0..."
docker exec -t $CONTAINER_NAME ip link set down dev eth0

# Check internet
docker exec -t $CONTAINER_NAME sh -ec "./setupsh.should \"fail if offline\" \"No internet\" 42 && exit 0"
EXIT_VALUE=$?
if [ "$EXIT_VALUE" != 0 ]; then
    echo "Exit value is $EXIT_VALUE"
    exit 1
fi

# Teardown (switch eth0 back on)
echo " Bringing up eth0..."
docker exec -t $CONTAINER_NAME ip link set up dev eth0
docker exec -t $CONTAINER_NAME ip r a default via 172.17.0.1 dev eth0


# Test - Check docker
#########################################

docker exec -t $CONTAINER_NAME sh -ec "./setupsh.should \"fail if docker is not installed\" \"You need docker to run Kuzzle\" 44 && exit 0"
EXIT_VALUE=$?
if [ $EXIT_VALUE -ne 0 ]; then
    exit $EXIT_VALUE
fi


# Test - Check docker-compose
#########################################

# Setup (install docker)
echo " Installing docker..."
sh -c "docker exec -t $CONTAINER_NAME /opt/test/fixtures-setupsh/install-docker.sh $OUTPUT"

# Check docker-compose
docker exec -t $CONTAINER_NAME sh -ec "./setupsh.should \"fail if docker-compose is not installed\" \"You need docker-compose to be able to run Kuzzle\" 44 && exit 0"
EXIT_VALUE=$?
if [ $EXIT_VALUE -ne 0 ]; then
    exit $EXIT_VALUE
fi


# Test - Check the existence of sysctl
#########################################

# Setup (install docker-compose)
echo " Installing docker-compose..."
sh -c "docker exec -t $CONTAINER_NAME /opt/test/fixtures-setupsh/install-docker-compose.sh $OUTPUT"

# Check if sysctl exists
if [ -z $(docker exec -t $CONTAINER_NAME sh -c "command -v sysctl") ]; then
    docker exec -t $CONTAINER_NAME sh -ec "./setupsh.should \"fail if sysctl is not installed\" \"This script needs sysctl\" 44 && exit 0"
    EXIT_VALUE=$?
    if [ $EXIT_VALUE -ne 0 ]; then
        exit $EXIT_VALUE
    fi
fi


# Test - Check vm_map_maxcount parameter
#########################################

# Setup (install sysctl and set bad value)
echo " Installing sysctl..."
sh -c "docker exec -t $CONTAINER_NAME /opt/test/fixtures-setupsh/install-sysctl.sh $OUTPUT"
echo " Setting bad vm.max_map_count..."
sh -c "docker exec -t $CONTAINER_NAME /opt/test/fixtures-setupsh/set-map-count.sh 242144 $OUTPUT"

# Check vm.max_map_count
docker exec -t $CONTAINER_NAME sh -ec "./setupsh.should \"fail if vm.max_map_count is too low\" \"The current value of the kernel configuration variable vm.max_map_count\" 44 && exit 0"
EXIT_VALUE=$?
if [ $EXIT_VALUE -ne 0 ]; then
    exit $EXIT_VALUE
fi

echo " Setting proper vm.max_map_count..."
sh -c "docker exec -t $CONTAINER_NAME /opt/test/fixtures-setupsh/set-map-count.sh 262144 $OUTPUT"


# Test - Download docker-compose.yml
#########################################

# Setup (redirect kuzzle.io to 127.0.0.1)
echo " Killing kuzzle.io..."
docker exec -t $CONTAINER_NAME sh -c "echo \"127.0.0.1 kuzzle.io\" >> /etc/hosts"

# Check vm.max_map_count
docker exec -t $CONTAINER_NAME sh -ec "./setupsh.should \"fail if downloading docker-compose.yml fails\" \"Cannot download\" 45 && exit 0"
EXIT_VALUE=$?
if [ $EXIT_VALUE -ne 0 ]; then
    exit $EXIT_VALUE
fi

# Teardown (clean-up /etc/hosts)
echo " Restoring kuzzle.io..."
# Note: sed -i works badly in a Docker container
docker exec -t $CONTAINER_NAME sh -c "cp /etc/hosts ~/hosts.new; sed -i '/kuzzle.io/d' ~/hosts.new; cp -f ~/hosts.new /etc/hosts"


# Test - Pull Kuzzle
#########################################
docker exec -t $CONTAINER_NAME sh -ec "./setupsh.should \"fail if dockerd is not running\" \"Pull failed.\" 1 && exit 0"
EXIT_VALUE=$?
if [ $EXIT_VALUE -ne 0 ]; then
    exit $EXIT_VALUE
fi

echo " Launching dockerd..."
sh -c "docker exec -t $CONTAINER_NAME /opt/test/fixtures-setupsh/launch-dockerd.sh $OUTPUT &"


# Test - Kuzzle works fine!
#########################################

docker exec -t $CONTAINER_NAME sh -ec "./setupsh.should \"run Kuzzle successfully\" \"Kuzzle successfully installed\" 0 && exit 0"
EXIT_VALUE=$?

exit $EXIT_VALUE